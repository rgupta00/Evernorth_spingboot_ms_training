Spring with Spring boot workshop:
_____________________________________

Key topics:
==================
=> Understand Depdendency Injection
=> bean wiring :xml, annoation, java configuraton
=> Spring boot aop
=> spring mvc basics
=> REST basics
=> Spring boot REST application
=> Spring AOP
=> Spring JDBCTemplate
=> Spring data
=> Spring boot web application, Spring MVC arch
=>Spring boot Monotring and Logging
=> spring boot profile
=> spring boot actuator
=> spring boot testing

=> Spring Boot microservice architecture
=> spring boot openfeign


Day 1: session 1:
____________________

Understand Depdendency Injection
_________________________________

What is the need of spring framework?
-----------------------------------


Lets take a example:

Rest 
Controller <------------ Service layer <---------- persistance layer <------ SessionFactory

ravi team		sumit team			kapil team

what sping does it produce loose coupling between the layer 
Take example lets say ravi team creating controller layer, sumit team is creating service layer and kapil team is
creating persitance layer... now controller layer need service and service layer need persistance layer

as we have design our application as per interface and we have use DI therefore kapil team can change implemenation
of service layer ( let earlier they are using Jdbc now wnat to use hibernate ) without effectiving even a single line
of code in Service layer (sumit team) do you not think it is great...

beside that spring DI help to manage dependency of our project and make our project flexiable


						---------- ProductDaoImplHib
						|
	ProductService <---------------- ProductDao-------ProductDaoImplJdbc
						|
						---------- ProductDaoImplUtil
		
public class Product {
		private Integer id;
		private String name;
		private BigDecimal price;	
}
					


public interface ProductDao {
	public List<Product>getProducts();
}


public interface ProductDaoImplUtil implements ProductDao {
	public List<Product>getProducts(){
		//collection implementation ....
	}
}

public interface ProductDaoImplJdbc implements ProductDao {
	public List<Product>getProducts(){
		//jdbc implementation ....
	}
}



public interface ProductService {
	public List<Product>getProducts();
}



public interface ProductServiceImpl  implements ProductService{

	private ProductDao productDao;

	public ProductServiceImpl(){
		productDao=new ProductDaoImplUtil();   // or ProductDaoImplJdbc()
	}


	public List<Product>getProducts(){
	// business logic
	}
}


=> we have to change the implementation ...whenever we swap dao layer :(


Spring BeanFactory vs ApplicationContext
______________________________________

 * BeanFactory:
 	 - light weight container , dont support many featues
 	  - dont use it
 BeanFactory applicationContext=new XmlBeanFactory(new ClassPathResource("demo.xml"));
 
 *  ApplicationContext 
  	- more powerful
    	ApplicationContext applicationContext=
				new ClassPathXmlApplicationContext("demo.xml");
				
	ApplicationContext
		-ClassPathXmlApplicationContext
		-FileSystemXmlApplicationContext
		-AnnotationConfigApplicationContext
		-XMLWebApplicationContext


spring bean configuration:
________________________
1. xml configuration
2. annotation configuration
3. java configuration


Understand Aspect Oriented Programming
______________________________________
	* If i need to take training at some client location, infra is provided by that client
		i need to only carray my laptop

	* help to achive high cohesion


 consider: we need to find how much time it take to execute code of service layer and do logging into a log file


public interface ProductServiceImpl  implements ProductService{

	private ProductDao productDao;

	public ProductServiceImpl(){
		productDao=new ProductDaoImplUtil();   // or ProductDaoImplJdbc()
	}


	public List<String>getProducts(){
	//how much it take to execute and do logging too ....
	// business logic
	}
}
 




session 2:
___________
MVC design pattern



History Spring boot : Summarized:
_________________________________

1.0.0: Support from Java 6 - 8
1.3.0: Support from Java 7 - 8, additional configuration for Java 6 required
2.0.0: Support from Java 8 - ...


	Advantage of spring boot , configuration spring boot
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 	Advantage of spring boot
	_____________________

	=> Auto-Configuration 

	=> Dependency Management

	=> Externalized Configuration
		bean can be configured through application.properties file 
		without touching java or xml config

	=> Production support
		We get health checking, application and jvm metrics, 
		jmx via http and a few more things for free

	=> Runnable Jars
		 We can package your application as a runnable jar with embedded tomcat
		 included so it presents a self-contained deployment unit

	=> Microservice


	configuration spring boot
	____________________

	create spring boot project: choose web, jpa, derby....

	//Configuration, @EnableAutoConfiguration and @ComponentScan



	@SpringBootApplication
	public class Application {
	
	  public static void main(String[] args) {
	    ApplicationContext ctx = SpringApplication.run(Application.class, args);
	
	    System.out.println("Let's inspect the beans provided by Spring Boot:");
	
	    String[] beanNames = ctx.getBeanDefinitionNames();
	    Arrays.sort(beanNames);
	    for (String beanName : beanNames) {
	        System.out.println(beanName);
	    }
	  }
	
	}

	spring-boot:run


	Spring boot ApplicationRunner and CommandLineRunner:
	----------------------------------------

	@Component
	public class ApplicationRunnerBean implements ApplicationRunner {
	@Override
	public void run(ApplicationArguments args) throws Exception {
		String collectStr = Arrays.stream(args.getSourceArgs()).collect(Collectors.joining(","));
		System.out.println(collectStr);
	}

	}
https://www.concretepage.com/spring-boot/spring-boot-commandlinerunner-and-applicationrunner-example#:~:text=The%20difference%20between%20CommandLineRunner%20and,spring%20ApplicationArguments%20as%20an%20argument.&text=To%20execute%20them%20in%20an,Order%20annotation%20or%20Ordered%20interface.
	Hello world:
	-----------

	
	@RestController
	public class HelloRestController {
		
		@RequestMapping("/hello")
		public String hello(){
			return "spring boot";
		}
           }  
	
	public class Product {
		private Integer id;
		private String name;
		private BigDecimal price;	
         }

	
	
	@GetMapping("products/{id}")
	public Book getProductById(@PathVariable(name = "id")int id) {
		return new Product(id, "java basics book", new BigDecimal(300));
	}





	application.properties
	---------------------------
	server.servlet.context-path=/productapp
	server.port=8080



Running spring boot :
____________________

	eclipse plugin
	spring initilizer
	spring cli

	https://www.journaldev.com/8195/spring-boot-cli-setup-and-helloworld-example

	spring init -n=jpa-one-to-one-demo -d=web,jpa,mysql --package-name=com.example.jpa demoproj


bannner:
________________
spring.banner.location=classpath:banner.txt

https://devops.datenkollektiv.de/banner.txt/index.html



java -jar  jpa_demo2-0.0.1-SNAPSHOT.jar --server.port=8050

https://docs.spring.io/spring-boot/docs/1.1.2.RELEASE/reference/html/common-application-properties.html



Note:Spring boot config: EnableAutoConfiguration
________________________________________________

disable all database related auto configuration in spring-boot
__________________________________________________________

@Configuration
@EnableAutoConfiguration(exclude = {DataSourceAutoConfiguration.class,
 DataSourceTransactionManagerAutoConfiguration.class, HibernateJpaAutoConfiguration.class})
@Profile ("client_app_profile_name")
public class ClientAppConfiguration {
    //it can be left blank
}




Day 2: 

session 1: spring boot rest crud application 
___________________________________________

Rest 
Controller <------------ Service layer <---------- persistance layer <------ SessionFactory




step 1: application.properties
_______________________
server.servlet.context-path=/productapp
server.port=8082

spring.datasource.url=jdbc:mysql://localhost:3306/demoms?useSSL=false
spring.datasource.username=root
spring.datasource.password=root
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver

spring.jpa.hibernate.ddl-auto=update
logging.level.org.springframework.web: DEBUG
logging.level.org.hibernate: ERROR
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.format_sql=true



UserInterface.PRODUCT_ADD_SUCCESS=product added successfully
UserInterface.PRODUCT_UPDATE_SUCCESS=product added successfully
UserInterface.PRODUCT_DELETE_SUCCESS=product added successfully

Service.PRODUCT_NOT_EXISTS=Product not exist


in case of h2 database :
---------------------

server.port=8090
server.servlet.context-path=/productapp
spring.h2.console.enabled=true
spring.datasource.url=jdbc:h2:mem:testdb
spring.datasource.driverClassName=org.h2.Driver
spring.datasource.username=sa
spring.datasource.password=password
spring.jpa.database-platform=org.hibernate.dialect.H2Dialect
# Custom H2 Console URL
spring.h2.console.path=/h2

spring.jpa.hibernate.ddl-auto=update

logging.level.org.springframework.web: DEBUG
logging.level.org.hibernate: ERROR

spring.jpa.show-sql=true 


YAML configuration
application.yaml
----------------------
spring:
  application:
    name: productappv1
  h2:
    console:
      path: /h2
      enabled: true
  datasource:
    url: jdbc:h2:mem:testdb
    driver-class-name: org.h2.Driver
    username: sa
    password: password
  jpa:
    database-platform: org.hibernate.dialect.H2Dialect
    hibernate:
      ddl-auto: update

server:
  port: 8090
  servlet:
    context-path: /productapp


Step 2: dao layer
_______________________
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@ToString
@Entity
@Table(name = "product_table")
public class Product {
	@Id @GeneratedValue(strategy = GenerationType.IDENTITY)
	private Integer id;
	private String name;
	private BigDecimal price;
	public Product(String name, BigDecimal price) {
		super();
		this.name = name;
		this.price = price;
	}
		
}

@Repository
public interface ProductDao extends JpaRepository<Product, Integer>{
	public Product findByName(String name);
}

Step 3: service layer
_______________________

public interface ProductService {
	public List<Product> findAll();
	public Product getById(int id);
	public Product addProduct(Product product);
	public Product updateProduct(int id, Product product);
	public Product deleteProduct(int id);
	
}



public class ProductNotFoundException extends RuntimeException{
	public ProductNotFoundException(String message) {
		super(message);
	}
}




@Service
@Transactional
public class ProductServiceImpl implements ProductService {

	private ProductDao productDao;

	@Autowired
	public ProductServiceImpl(ProductDao productDao) {
		this.productDao = productDao;
	}

	@Override
	public List<Product> findAll() {
		return productDao.findAll();
	}

	@Override
	public Product getById(int id) {
		return productDao.findById(id)
				.orElseThrow(() -> new ProductNotFoundException("product with id" + id + " is not found"));
	}

	@Override
	public Product addProduct(Product product) {
		productDao.save(product);
		return product;
	}

	@Override
	public Product updateProduct(int id, Product product) {
		Product productToUpdate= getById(id);
		productToUpdate.setPrice(product.getPrice());
		productDao.save(productToUpdate);
		return productToUpdate;
	}

	@Override
	public Product deleteProduct(int id) {
		Product productToDelete= getById(id);
		productDao.delete(productToDelete);
		return productToDelete;
	}

}


Step 4: rest controller
_______________________
@RestController
public class ProductController {

	private ProductService productService;

	@Autowired
	public ProductController(ProductService productService) {
		this.productService = productService;
	}
	@GetMapping(path = "products")
	public List<Product>findAll(){
		return productService.findAll();
	}
	
	@GetMapping(path = "products/{id}")
	public Product findById(@PathVariable(name = "id") int id){
		return productService.getById(id);
	}
	
	@PostMapping(path = "products")
	public Product addProduct( @RequestBody Product product){
		return productService.addProduct(product);
	}
	
	@DeleteMapping(path = "products/{id}")
	public Product deleteProduct(@PathVariable(name = "id") int id){
		return productService.deleteProduct(id);
	}
	
	@PutMapping(path = "products/{id}")
	public Product updateProduct(@PathVariable(name = "id") int id, @RequestBody Product product){
		return productService.updateProduct(id, product);
	}
}



Let




Step 5: rest controller: ResponseEntity
_______________________________________

@RestController
public class ProductController {

	private ProductService productService;

	@Autowired
	public ProductController(ProductService productService) {
		this.productService = productService;
	}
	
	@GetMapping(path = "products")
	public ResponseEntity<List<Product>> findAll(){
		return ResponseEntity.status(HttpStatus.OK).body(productService.findAll());
	}
	
	@GetMapping(path = "products/{id}")
	public ResponseEntity<Product> findById(@PathVariable(name = "id") int id){
		return ResponseEntity.ok(productService.getById(id));
	}
	
	@PostMapping(path = "products")
	public ResponseEntity<Product> addProduct( @RequestBody Product product){
		return ResponseEntity.status(HttpStatus.CREATED).body(productService.addProduct(product));
	}
	
	@DeleteMapping(path = "products/{id}")
	public ResponseEntity<Void> deleteProduct(@PathVariable(name = "id") int id){
		 productService.deleteProduct(id);
		 return ResponseEntity.status(HttpStatus.NO_CONTENT).build();
	}
	
	@PutMapping(path = "products/{id}")
	public ResponseEntity<Product> updateProduct(@PathVariable(name = "id") int id, @RequestBody Product product){
		return ResponseEntity.status(HttpStatus.CREATED).body(productService.updateProduct(id, product));
	}
}

Spring data quaries:
---------------------

	@Query("select p from Product p")
	List<Product> getListOfAllProducts();
	
	
	@Query("select p from Product p where p.name=?1")
	List<Product> getListOfAllProductsBasedOnName(String name);
	
	@Query("select p from Product p where p.name=:name")
	List<Product> getListOfAllProductsBasedOnNameV2(@Param("name")  String name);
	

	@Query("select p from Product p where p.name=?1 and p.price=?2")
	List<Product> getListOfAllProductsBasedOnNameAndPrice(String name, BigDecimal price);
	
	@Query("select p from Product p where p.name=?1 or p.price=?2")
	List<Product> getListOfAllProductsBasedOnNameOrPrice(String name, BigDecimal price);
	
	
	List<Product> findByName(String name);
	
	List<Product> findByNameContaining(String name);
	List<Product> findByNameLike(String name);
	List<Product> findByNameStartingWith(String name);
	
	List<Product> findByNameEndingWith(String name);
	
	List<Product> findByNameIgnoreCase(String name);
	
	
	List<Product> findByMfgDateAfter(LocalDate date);
	List<Product> findByMfgDateBefore(LocalDate date);
	List<Product> findByMfgDateBetween(LocalDate date1, LocalDate date);
	
	



Spring data pagination:
----------------------



adding multiple products
-----------------------------

		List<Product>products=IntStream.rangeClosed(1, 2000)
				.mapToObj(i-> new Product("product "+i, new Random().nextDouble(5000)))
				.toList();
		
		//productRepo.saveAll(products);
		
		
		
	
service layer:
-------------------
	public List<Product> getAllProductSorted(String field);
	public Page<Product> getAllProductPage(int offset, int pageSize);
	public Page<Product> getAllProductPageSorted(String field,int offset, int pageSize);
	
	
	
	
service layer implementation
--------------------------

	@Override
	public List<Product> getAllProductSorted(String field) {
		return productRepo.findAll(Sort.by(Sort.Direction.DESC, field));
	}

	@Override
	public Page<Product> getAllProductPage(int offset, int pageSize) {
		return productRepo.findAll(PageRequest.of(offset, pageSize));
	}

	@Override
	public Page<Product> getAllProductPageSorted(String field, int offset, int pageSize) {
		return productRepo.findAll(PageRequest.of(offset, pageSize).withSort(Sort.by(field)));
	}
	
	
	
controller layer:
---------------
	
	@GetMapping(path = "productsorted")
	public List<Product> getAllProductSorted(@RequestParam(name="field")  String field) {
		return productService.getAllProductSorted(field);
	}

	//productpage?offset=4&pageSize=20
	@GetMapping(path = "productpage")
	public Page<Product> getAllProductPage(@RequestParam(name="offset") int offset,@RequestParam(name="pageSize") int pageSize) {
		return productService.getAllProductPage(offset, pageSize);
	}

	//productpagesorted?offset=4&pageSize=20&field=id
	@GetMapping(path = "productpagesorted")
	public Page<Product> getAllProductPageSorted(int offset, int pageSize,String field) {
		return productService.getAllProductPageSorted(field, offset, pageSize);
	}
		
		


Step 6: rest controller exception handling
_______________________________________
@ResponseStatus(code =HS.NotFound)
ProductNotFoundException extends RuntimeExcetion{
}


@Data
@NoArgsConstructor
@AllArgsConstructor
public class ErrorDetails {
	private String message;
	private String statusCode;
	
	private String name;
    private LocalDateTime localDateTime;
	
}



@RestControllerAdvice
public class ExHandlerController {

    @ExceptionHandler(ProductNotFoundException.class)
    public ResponseEntity<ErrorDetails> handle404(ProductNotFoundException ex){
        ErrorDetails details=new ErrorDetails();
        details.setLocalDateTime(LocalDateTime.now());
        details.setMessage(ex.getMessage());
        details.setName("rgupta.mtech@gmail.com");
        details.setStatusCode(HttpStatus.NOT_FOUND.toString());
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(details);
    }
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorDetails> handle500(Exception ex){
        ErrorDetails details=new ErrorDetails();
        details.setMessage(ex.getMessage());
        details.setLocalDateTime(LocalDateTime.now());
        details.setName("rgupta.mtech@gmail.com");
        details.setStatusCode(HttpStatus.INTERNAL_SERVER_ERROR.toString());
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(details);
    }
}


Step 7: JSR 303 validation api , exception handling
__________________________________________________

1. add validation api

2. apply @valid in post and update method 

3. 

@Data
@NoArgsConstructor
@AllArgsConstructor
public class ProductDto {

	private int id;
	
	@NotNull(message = "{product.name.absent}")
	@Pattern(regexp = "[A-Za-z]+( [A-Za-z]+)*", message = "{product.name.invalid}")
	private String name;

	@NotNull(message = "{product.price.absent}")
	@Range(min = 100, max = 100000, message = "{product.price.invalid}")
	private BigDecimal price;

}


4. create exception handler

    @ResponseStatus(HttpStatus.BAD_REQUEST)
	@ExceptionHandler(MethodArgumentNotValidException.class)
	public Map<String, String> handleInvalidArgument(MethodArgumentNotValidException ex) {

		Map<String, String> errorMap = new HashMap<>();
		ex.getBindingResult().getFieldErrors().forEach(error -> {
			errorMap.put(error.getField(), error.getDefaultMessage());
		});
		return errorMap;
	}


ValidationMessages.properties
-----------------------------

product.name.absent=Please provide product name
product.name.invalid=product Name should contain only alphabets and space

product.price.absent=Please provide product price 
account.price.invalid=Please provide correct price bw 100 to 100000


	Other validation example:
	-------------------------

	@Email(message = "{account.email.invalid}")
	@NotNull(message = "{account.email.absent}")
	private String email;
	
	@NotNull(message = "{account.phone.absent}")
	@Pattern(regexp = "[789][0-9]{9}", message = "{account.phone.invalid}")
	private String phone;



	private String category;
	
		EL BOOKS FMCG
	
	
Implementation of custom valiation logic:
-------------------------------------------

setp 1: create ProductTypeValidator need to be used by custom annotation

public class ProductTypeValidator implements ConstraintValidator<ValidateProductType, String> {
    @Override
    public boolean isValid(String productType, ConstraintValidatorContext constraintValidatorContext) {
        List<String> productTypes = Arrays.asList("EL", "BOOK","FMCG);
        return productTypes.contains(productType);
    }
}



setp 2: create Custom annotation

@Target({ElementType.FIELD,ElementType.PARAMETER})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Constraint(validatedBy = ProductTypeValidator.class)
public @interface ValidateProductType {

    public String message() default "Invalid productType: It should be either EL, BOOK,FMCG;

    Class<?>[] groups() default {};

    Class<? extends Payload>[] payload() default {};
}



//custom annotation
    @ValidateProductType
    private String productType; //Electronic or Books
    

    

Supporting both xml and json:
	_______________________________

	Step 1: put parser for xml

	     <dependency>
			<groupId>com.fasterxml.jackson.dataformat</groupId>
			<artifactId>jackson-dataformat-xml</artifactId>
	     </dependency>

	Step 2:
	@GetMapping(path = "products", produces = {MediaType.APPLICATION_JSON_VALUE, 
			MediaType.APPLICATION_XML_VALUE})





spring boot reading property files:
---------------------------------

1. @Value annotation
2. Enviornment
3. @ConfigrationProperties


@EnableConfigurationProperties(InfoDto.class)

@ConfigrationProperties(prefix="db")

Example:
--------
account:
  message: "welcome to productapp account manager"
  contactDetails:
    name: "raj"
    email: "rgupta.mtech@gmail.com"
  onCallSupport:
    -54645464556
    -75765777677
	
	

@ConfigurationProperties(prefix = "account")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class InfoDto {
    private String message;
    private Map<String, String>contactDetails;
    private List<String>onCallSupport;
}







Spring boot loging customization:
_____________________________________

<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter</artifactId>
    <exclusions>
        <exclusion>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-logging</artifactId>
        </exclusion>
    </exclusions>
</dependency>

<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-log4j2</artifactId>
</dependency>


spring boot logging:
-------------------
 	     
Disable logging :
---------------
logging.level.root=OFF
logging.level.org.springframework.boot=OFF
spring.main.banner-mode=OFF   

	     
     
Customizing logging :
---------------	     
logging.level.org.springframework.web: DEBUG
logging.level.org.hibernate: ERROR

logging.level.com.productapp=info


logging.level.org.springframework.web: DEBUG
logging.level.org.hibernate: ERROR


# Logging pattern for the console
logging.pattern.console= "%d{yyyy-MM-dd } [%thread] %-5level %logger{36} - %msg%n"
#logging pattern for file
logging.pattern.file= "%d{yyyy-MM-dd } [%thread] %-5level %logger{36} - %msg%n"

logging.file.name=/home/raj/Desktop/logs/server.log
	     
	     
 
	     
	     

   



richardson maturity model
_________________________

Step 8: hateoas: Hypermedia as the Engine of Application State (HATEOAS)
__________________

 1: put hateoas dependencies

 2: enable static improt:

import static org.springframework.hateoas.server.mvc.WebMvcLinkBuilder.*;

 3: change POJO class:

public class Product extends RepresentationModel<Product> {
} 



@GetMapping(path = "productsV2/{id}")
	public EntityModel<Product>  findByIdLink(@PathVariable(name = "id") int id){
		Link link=linkTo(methodOn(ProductController.class).findByIdLink(id)).withSelfRel();
		Product product=productService.getById(id);
		product.add(link);
		return EntityModel.of(product);
}

@GetMapping(path = "productsV2")
	public CollectionModel<Product> findAllV2(){
		List<Product> products=productService.findAll();
		for(Product product: products) {
			Link link=linkTo(methodOn(ProductController.class).findByIdLink(product.getId())).withSelfRel();
			product.add(link);
		}
		return CollectionModel.of(products);
}



9. Using OpenAPI 3.0
_____________________
https://www.bezkoder.com/spring-boot-swagger-3/
https://www.baeldung.com/spring-rest-openapi-documentation

https://editor.swagger.io/

=> Documenting a Spring REST API Using OpenAPI 3.0
=>Swagger is almost equivalent to SOAP formate, used for documentation of REST api

		Step 1:

	<dependency>
		<groupId>org.springdoc</groupId>
		<artifactId>springdoc-openapi-starter-webmvc-ui</artifactId>
		<version>2.2.0</version>
	</dependency>

	Step 2:

	http://localhost:8090/bookapp/v3/api-docs
	
	http://localhost:8090/bookapp/swagger-ui/index.html

	http://localhost:8090/bookapp/v3/api-docs.yaml

	Step 3:
	Customization location
	springdoc.swagger-ui.path=/swagger-ui-bookapp.html

	@OpenAPIDefinition(info = @Info(title = "bookapp API", version = "2.0" , description = "YMSLI bookapp API"))
	public class BookappApplication implements CommandLineRunner {
	}


	
	@OpenAPIDefinition(
			info = @Info(
					title = "",
					description = "",
					version = "v1",
					contact = @Contact(
							name = "",
							email = "",
							url = ""
					),
					license = @License(
							name = "Apache 2.0",
							url = "https://www.cbre.com"
					)
			),
			externalDocs = @ExternalDocumentation(
					description =  "",
					url = "https://www.cbre.com/swagger-ui.html"
			)
	)


10. caching
_____________
1. In memory cache
-------------------

step 1: configuration of cache

@Configuration
@EnableCaching
public class CachingConfig {
	@Bean
	public CacheManager cacheManager(){
		ConcurrentMapCacheManager cacheManager=new ConcurrentMapCacheManager("products");
		return cacheManager;
		
	}
}


Step 2: applying cache annotations on service layer

@Slf4j
@Service
@Transactional
public class ProductServiceImpl implements ProductService {

	
	@Cacheable(value="products")
	@Override
	public List<Product> findAll() {
		//
	}

	@Cacheable(value="products", key = "#id")
	@Override
	public Product getById(int id) {
		//
	}

	@CachePut(value="products", key="#result.id")
	@Override
	public Product addProduct(Product product) {
		//
	}

	@CachePut(value="products", key="#result.id")
	@Override
	public Product updateProduct(int id, Product product) {
		//
	}

	@CacheEvict(value="products", key="#id")
	@Override
	public Product deleteProduct(int id) {
		//
	}

	@CacheEvict(value="products", allEntries=true)
	@Override
	public void evictCache() {
		log.info("cache is cleared...");
	}

}


redis & redis cache
=================
 What is Redis?
	Redis (Remote Dictionary Server) is an open-source,
	in-memory data structure store used as a database, cache, and message broker.

	It supports data structures like strings, hashes, lists, sets, sorted sets, etc.

 Why Use Redis for Caching?
		Ultra-fast data access due to in-memory storage.

	Reduces database load and improves application performance.

	Ideal for read-heavy applications.

Redis with Spring Boot
-----------------------
step 0: docker compose configuration

docker-compose.yml
---------------------
services:
  redis:
    image: redis:7.4.2
    ports:
      - "6379:6379"
	  
	  
Step 1: add dependencies
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-data-redis</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-cache</artifactId>
		</dependency>

step 2: configure cache
----------------------
spring:
  application:
    name: productappv1
  cache:
    type: redis
  data:
    redis:
      host: localhost
      port: 6379
	  

	Common Use Cases
	---------------
		Caching database queries
		Storing session data
		Rate limiting
		Leaderboards, real-time analytics

	Benefits
	--------
	High performance
	Scalability
	Persistence option (if needed)
	Pub/Sub capabilities


https://www.javatpoint.com/redis-tutorial

What is redis Usage ?
-----------------
	Database
	Cache
	Message broker
	
Can be used with different languages



Redis as Cache?
------------------
spring:
  application:
    name: productappv1
  cache:
    type: redis
  data:
    redis:
      host: localhost
      port: 6379






Step 11: schedule processes
____________________________

	Note:
	The simple rules that we need to follow to annotate a method with @Scheduled are:

			a method should have the void return type
			a method should not accept any parameters

	step 1: put @EnableScheduling on bootstrap class

	step 2: create an component with @Scheduled annotation

				
		@Service
		public class ScheduledJob {
			private Logger logger = LoggerFactory.getLogger(ScheduledJob.class);
		
			@Autowired
			private ProductService service;
		
			@Scheduled(cron = "0,30 * * * * *")
			public void cronJob() {
				logger.info("> cronJob");
		
				List<Product> products = service.findAll();
				logger.info("There are {} products in the data store.", products.size());
		
				logger.info("< cronJob");
			}
		
			// after application startup delay of 5 sec, schedule to run each after 15
			
			@Scheduled(initialDelay = 5000, fixedRate = 15000)
			public void fixedRateJob() {
				logger.info("> fixedRateJob");
		
				// Add scheduled logic here
		
				List<Product> products = service.findAll();
				
				logger.info("There are {} books in the data store.", products.size());
		
				logger.info("< fixedRateJob");
			}
		
		}


ref:
https://www.baeldung.com/spring-scheduled-tasks
https://www.tutorialspoint.com/unix_commands/crontab.htm




Spring boot Actuator:
-------------------------

server.port=8080
spring.devtools.restart.enabled=true
#management.endpoints.web.exposure.exclude=*
management.endpoints.web.exposure.include=health, custom-endpoint

management.endpoint.health.show-details=always

management.health.disk.enabled=true
management.health.livenessstate.enabled=true
management.health.readinessstate.enabled=true
management.server.port=9090


#/actuator/info endpoint will show the information given here, keys
# that are started with info
info.app.encoding=UTF-8
info.app.java.source=11
info.app.java.target=11
info.app.name=spring booot actuator

management.endpoint.info.enabled=true
management.endpoint.health.enabled=true


Custom end points

@Configuration
@Endpoint(id = "custom-endpoint")
public class CustomEndpoints {
    @ReadOperation
    public String getCustomData(){
        return "This is custom Data";
    }
}


Getting started with mongodb:
----------------------------

docker-compose.yml
---------------
version: '4'
services:
  mongodb:
    image: mongo:7.0.5
    container_name: mongodb
    ports:
      - "27018:27017"
    environment:
      MONGO_INITDB_DATABASE: product-service
	  
  mysql:
    image: mysql:8.3.0
    container_name: mysql
    environment:
      MYSQL_ROOT_PASSWORD: mysql
    ports:
      - "3316:3306"

Creating collections, document, storing data etc:
__________________________________________

show dbs 		// List all databases
use rajdb 		//Switches to inventory
show collections  	//List all tables in the current selected database

Creating collections, document, storing data etc
__________________________________________

	use rajdb;	// create as well switch to rajdb



choose dependencies: web, devtools, mongo
step 1: Dao layer
____________________

@Document(collection = "products")
public class Product {
    @Id
    private String id;
    private String name;
    private BigDecimal price;
    private String category;
    
}


@Repository
public interface ProductRepo extends MongoRepository<Product, Integer> {
    public List<Product> findByName(String name);
}


step 5: application.properties
___________________
server.servlet.context-path=/empapp
server.port=8080
spring.data.mongodb.host=localhost
spring.data.mongodb.port=27017
spring.data.mongodb.database=mongodb
spring.data.mongodb.repositories.enabled=true




Spring boot js
----------------
  <script>
        let data = fetch('http://localhost:8080/empapp/employee')
        data.then((item) => {
            return item.json();
        }).then((result) => {
            console.log(result);
        })

    </script>











Spring boot testing
=========================
* Junit mockito intro
* Spring boot testing
* Communication bw spring boot applications


Basics Recap Junit and mockito:
------------------------------

Unit testing:
	where any given test covers the smallest unit of a program (a function or procedure).
	 It may or may not take some input parameters and may or may not return some values.

Integration testing:
	 where individual units are tested together to check whether all the
	 units interact with each other as expected.


To define one Test case we should use
  a. JUnit 5 Annotations  
  b. JUnit 5 Assert API


Some imp Junit 5 annotations
------------------------
@Test
@DisplayName
@BeforeEach
@AfterEach
@BeforeAl
@AfterAll
@Disable
@TestMethodOrder
@RepeatTest
@Tag
@ParameterizedTest

@BeforeEach : To execute any logic once per test method before starting test method.
@AfterEach  : To execute any logic once per test method after finishing test method.

@BeforeAll : To execute any logic once per test case before starting.
@AfterAll  : To execute any logic once per test case after finishing.

Calculator example:
------------------

	@Test
	void testDivide() {
		Assertions.assertThrows(ArithmeticException.class, ()-> cal.divide(3, 0));
	}
	
		
	@Test
	void testDivide() {
		int sum=Assertions.assertTimeout(Duration.ofMillis(100), ()-> cal.add(2, 1));
	}
	
	

@TestMethodOrder(MethodOrderer.OrderAnnotation.class)

@EnabledOnOs(OS.LINUX)
@EnabledOnJre(JRE.JAVA_15)
@DisplayName("test for add employee")
@Order(value = 1)

AssertEquals()
assertNotNull(object):
assertNull(object):
assertTrue()/assertFalse()
assertAll(Executable...) 
assertThrow()
assertNotThrow()
assertTimeOut()




Demo @TestMethodOrder:
_____________________
@TestMethodOrder : We can define multiple test methods inside Testcase.
 Those are executed in Random order by default.

We can specify our own order using @TestMethodOrder + OrderAnnotation
Here we need to provide @Order(number).


@TestMethodOrder(OrderAnnotation.class)
public class TestEmployee {

	@Order(value = 1)
	@Test
	public void testSave() {
		System.out.println("saving");
	}
	
}


@DisplayName : This annotation is used to provide 'Readable text' inplace of
                   actual method and class names at JUnit console.

Eg:
DisplayName("test for employee dao")
public class TestEmployee {

	@DisplayName("test for saving employee dao")
	@Test
	public void testSave() {
		System.out.println("saving");
	}
	//

}



@Disabled :    This annotation is used to specify Ignore one Test-method 
               while executing test-case (do not execute test method)


@Tag 
----------

	These are used to filter test methods for execution in different environments.

	For Example, i want to test export example in production env at same
	    i want to test delete operation only in development environment 
	then use tag concept and maven-surefire-plugin in pom.xml


@DisplayName("test for employee dao")
public class TestEmployee {

	@DisplayName("test for saving employee dao")

	@Test
	public void testSave(TestInfo info) {
		System.out.println(info.getTestMethod().toString());
		System.out.println("saving");
	}
	@Tag(value = "dev")
	@Test
	public void testUpdate() {
		System.out.println("updating ");
	}
	
	@Tag(value = "prod")
	@Test
	public void testDelete() {
		System.out.println("deleting");
	}
}

	 <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-surefire-plugin</artifactId>
                <version>3.0.0-M5</version>
                <configuration>
                    <!-- include tags -->
                    <groups>prod</groups>
                    <!-- exclude tags -->
                    <excludedGroups>dev</excludedGroups>
                </configuration>
            </plugin>
        </plugins>
    </build>

@ParameterizedTest
___________________

	@ParameterizedTest
	@CsvFileSource(resources = "/data.csv", numLinesToSkip = 1)
	void toUpperCase_ShouldGenerateTheExpectedUppercaseValueCSVFile(
	  String input, String expected) {
	    String actualValue = input.toUpperCase();
	    assertEquals(expected, actualValue);
	}

input,expected
test,TEST
tEst,TEST
Java,JAVA


junit mock testing:
_______________
What is Mocking and When Does It Come into the Picture?
___________________________________________________

	What if we want to test service layer without completion of dao layer?
	What if we want to test one service which depend on an service available on other application?

	=> mockito used for mocking

getting started:
------------------

Why mockito?
-----------
public interface BookDao {
	public List<String> getBooks();
}


public class BookDaoImpl implements BookDao {
	@Override
	public List<String> getBooks() {
		return Arrays.asList("java","rich dad poor dad","java adv");
	}
}


public interface BookService {
	public List<String> getBooks(String subject);
}



public class BookServiceImpl implements BookService {
	private BookDao bookDao;

	public void setBookDao(BookDao bookDao) {
		this.bookDao = bookDao;
	}

	@Override
	public List<String> getBooks(String subject) {
		return bookDao.getBooks().stream().filter(title -> title.contains(subject)).collect(Collectors.toList());
	}

}





import org.junit.Assert; 


public class DemoTest {

	@Test
	public void getBookTest() {
		BookDao dao=new BookDaoImpl();
		
		BookServiceImpl bookService=new BookServiceImpl();
		bookService.setBookDao(dao);
		List<String> books=bookService.getBooks("java");
		Assert.assertEquals(2, books.size());
	}
}



mockito with annotations:
----------------------

@ExtendWith(MockitoExtension.class)
class BookServiceImplTest {

	@InjectMocks
	private BookServiceImpl bookServiceImpl;
	
	@Mock
	private BookDao bookDao;
	
	@BeforeEach
	void setUp() throws Exception {
		List<String> allBooks=Arrays.asList("java","rich dad poor dad","java adv");
		when(bookDao.getBooks()).thenReturn(allBooks);
		
	}

	@AfterEach
	void tearDown() throws Exception {
	}

	@Test
	void test() {
		List<String> books=bookServiceImpl.getBooks("java");
		assertEquals(2, books.size());
	}

}


MockitoAnnotations.initMocks(this) vs @RunWith(MockitoJUnitRunner.class)

Note:
----
Mockito cannot mock or spy on Java constructs such as final classes and
methods, static methods, enums, private methods, the equals() and
hashCode() methods, primitive types, and anonymous classes



Partial Mocking: @Spy
--------------------
  When we want an object in the test class to mock some method(s),
 but also call some actual method(s), then we need partial mocking. 
  This is achieved via @Spy

	Unlike using @Mock, with @Spy, a real object is created, 
	but the methods of that object can be mocked or can be actually called—whatever we need.


Example:
--------
@Repository
public class BookDaoImpl implements BookDao {
	@Override
	public List<String> getBooks() {
		log();
		return null;
	}

	public void log() {
		System.out.println("----------");
	}
}



@RunWith(MockitoJUnitRunner.class)
public class DemoTest {

	@Spy
	BookDaoImpl dao;
	
	@InjectMocks
	BookServiceImpl bookService;

	// when tested log() method is going to be called.....

}


Testing Spring boot application:
---------------------------------
	
	web---------- service ------------- repo -----db
	unit testing
	|<-------------integration testing ------->|



Testing spring boot repo layer:
----------------------------
Refer productstore application

application.properties
---------------------
server.port=8080
spring.h2.console.enabled=true
spring.datasource.url=jdbc:h2:mem:testdb
spring.datasource.driverClassName=org.h2.Driver
spring.datasource.username=foo
spring.datasource.password=foo
spring.jpa.database-platform=org.hibernate.dialect.H2Dialect

# Custom H2 Console URL
spring.h2.console.path=/h2

spring.jpa.hibernate.ddl-auto=update



testing dao layer:
---------------------
import com.productapp.entities.Product;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;
import org.springframework.test.annotation.Rollback;

import java.math.BigDecimal;
import java.util.List;
import java.util.Optional;
import static org.assertj.core.api.Assertions.assertThat;
@DataJpaTest
class ProductRepoTest {
    @Autowired
    private ProductRepo productRepo;

    private Product product;

    @BeforeEach
    void setUp() {
        product=new Product("laptop", BigDecimal.valueOf(120000));
    }

    @Test
    @Rollback(value = true)
    public void givenProductObjectWhenSaveReturnProductObject(){
        Product productSaved=productRepo.save(product);
        assertThat(productSaved).isNotNull();
        assertThat(productSaved.getId()).isGreaterThan(0);
    }
    @DisplayName("JUnit test for get all employees operation")
    @Test
    public void givenProductList_whenFindAll_thenProductList(){
        //given
        Product p1=new Product("laptop",BigDecimal.valueOf(120000));
        Product p2=new Product("laptop cover",BigDecimal.valueOf(1200));
        productRepo.save(p1);
        productRepo.save(p2);
        // when -  action or the behaviour that we are going test
        List<Product> productList=productRepo.findAll();
        // then - verify the output
        assertThat(productList).isNotNull();
        assertThat(productList.size()).isEqualTo(2);
    }
    @DisplayName("JUnit test for get product by id operation")
    @Test
    public void givenProductObject_whenFindById_thenReturnProductObject(){
        // given - precondition or setup
        Product p1=new Product("laptop",BigDecimal.valueOf(120000));
        productRepo.save(p1);

        // when -  action or the behaviour that we are going test
        Product productDB = productRepo.findById(p1.getId()).get();
        // then - verify the output
        assertThat(productDB).isNotNull();
    }
    @DisplayName("JUnit test for update product operation")
    @Test
    public void givenEmployeeObject_whenUpdateEmployee_thenReturnUpdatedEmployee(){
        // given - precondition or setup
        Product p1=new Product("laptop",BigDecimal.valueOf(120000));
        productRepo.save(p1);
        // when -  action or the behaviour that we are going test
        Product savedProduct = productRepo.findById(p1.getId()).get();
        savedProduct.setPrice(BigDecimal.valueOf(120000));
        Product updatedProduct =  productRepo.save(savedProduct);

        assertThat(updatedProduct.getPrice()).isEqualTo(BigDecimal.valueOf(120000));
    }

    @DisplayName("JUnit test for delete product operation")
    @Test
    public void givenProductObject_whenDelete_thenRemoveProduct() {
        // given - precondition or setup
        Product p1 = new Product("laptop", BigDecimal.valueOf(120000));
        productRepo.save(p1);

        // when -  action or the behaviour that we are going test
        productRepo.deleteById(p1.getId());
        List<Product> products = productRepo.findAll();
        // then - verify the output
        assertThat(products.size()).isEqualTo(0);
    }


    @AfterEach
    void tearDown() {
    }
}


service layer testing:
---------------------

import com.productapp.entities.Product;
import com.productapp.repository.ProductRepo;
import org.assertj.core.api.Assertions;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import java.math.BigDecimal;
import java.util.Collections;
import java.util.List;

import static org.assertj.core.api.AssertionsForClassTypes.assertThat;
import static org.mockito.BDDMockito.given;
@ExtendWith(MockitoExtension.class)
class ProductServiceImplTest {
    @Mock
    private ProductRepo productRepo;

    @InjectMocks
    private ProductServiceImpl productService;

    private Product product;

    @BeforeEach
    void setUp() {
        product=new Product("laptop", BigDecimal.valueOf(120000));
    }

    @DisplayName("JUnit test for save Product method")
    @Test
    public void givenProductObject_whenSaveProduct_thenReturnProductObject(){
        // given - precondition or setup
        given(productRepo.save(product)).willReturn(product);
        Product savedProduct = productService.addProduct(product);
        assertThat(savedProduct).isNotNull();
    }


    @DisplayName("JUnit test for getAll Product method")
    @Test
    public void givenProductList_whenGetAllProduct_thenReturnProductList(){
        // given - precondition or setup
        Product  product2=new Product("laptop cover", BigDecimal.valueOf(1200));

        given(productRepo.findAll()).willReturn(List.of(product,product2));

        // when -  action or the behaviour that we are going test
        List<Product> productList = productService.getAll();

        // then - verify the output
        Assertions.assertThat(productList).isNotNull();
        Assertions.assertThat(productList.size()).isEqualTo(2);
    }


    @DisplayName("JUnit test for getAll Product method (negative scenario)")
    @Test
    public void givenEmptyEmployeesList_whenGetAllEmployees_thenReturnEmptyEmployeesList(){
        // given - precondition or setup
        given(productRepo.findAll()).willReturn(Collections.emptyList());

        // when -  action or the behaviour that we are going test
        List<Product> employeeList = productService.getAll();
        // then - verify the output
        Assertions.assertThat(employeeList).isEmpty();
        Assertions.assertThat(employeeList.size()).isEqualTo(0);
    }

    @AfterEach
    void tearDown() {
    }
}



controller layer testing:
---------------------------

import com.productapp.entities.Product;
import com.productapp.service.ProductService;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;
import org.springframework.boot.test.mock.mockito.MockBean;
import org.springframework.http.MediaType;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.test.web.servlet.ResultActions;

import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.List;

import static org.hamcrest.CoreMatchers.is;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.BDDMockito.given;
import static org.mockito.BDDMockito.willDoNothing;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
import static org.springframework.test.web.servlet.result.MockMvcResultHandlers.print;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

@WebMvcTest
class ProductControllerTest {

    @Autowired
    private MockMvc mockMvc;

    @MockBean
    private ProductService productService;

    @Autowired
    private ObjectMapper objectMapper;

    @Test
    public void givenProductObject_whenCreateProduct_thenReturnSavedProduct() throws Exception{

        // given - precondition or setup
        Product product=new Product("laptop", BigDecimal.valueOf(120000));
        given(productService.addProduct(any(Product.class)))
                .willAnswer((invocation)-> invocation.getArgument(0));

        // when - action or behaviour that we are going test
        ResultActions response = mockMvc.perform(post("/products")
                .contentType(MediaType.APPLICATION_JSON)
                .content(objectMapper.writeValueAsString(product)));

        // then - verify the result or output using assert statements
        response.andDo(print()).
                andExpect(status().isOk())
                .andExpect(jsonPath("$.name",
                        is(product.getName())))
                .andExpect(jsonPath("$.price",
                        is(product.getPrice().intValue())));
    }
    @Test
    public void givenListOfProducts_whenGetAllProducts_thenReturnProductList() throws Exception{
        // given - precondition or setup
        List<Product> listOfProducts = new ArrayList<>();
        listOfProducts.add(Product.builder().name("a").price(BigDecimal.valueOf(120000)).build());
        listOfProducts.add(Product.builder().name("b").price(BigDecimal.valueOf(120000)).build());
        given(productService.getAll()).willReturn(listOfProducts);

        // when -  action or the behaviour that we are going test
        ResultActions response = mockMvc.perform(get("/products"));

        // then - verify the output
        response.andExpect(status().isOk())
                .andDo(print())
                .andExpect(jsonPath("$.size()",
                        is(listOfProducts.size())));

    }

    // positive scenario - valid employee id
    @Test
    public void givenProductId_whenGetProductById_thenReturnProductObject() throws Exception{
        // given - precondition or setup
        int productId = 1;
        Product product=new Product(1,"laptop", BigDecimal.valueOf(120000));
        given(productService.getProductById(productId)).willReturn(product);

        // when -  action or the behaviour that we are going test
        ResultActions response = mockMvc.perform(get("/products/{id}", productId));

        // then - verify the output
        response.andExpect(status().isOk())
                .andDo(print())
                .andExpect(jsonPath("$.name", is(product.getName())))
                .andExpect(jsonPath("$.price", is(product.getPrice().intValue())));

    }


    // @Test
    public void givenInvalidProductId_whenGetProductById_thenReturnEmpty() throws Exception{
        // given - precondition or setup
        int productId = 1;
        Product product=new Product(1,"laptop", BigDecimal.valueOf(120000));
        given(productService.getProductById(productId)).willReturn(null);

        // when -  action or the behaviour that we are going test
        ResultActions response = mockMvc.perform(get("/products/{id}", productId));

        // then - verify the output
        response.andExpect(status().isNotFound())
                .andDo(print());

    }
    
    @BeforeEach
    void setUp() {
    }

    @AfterEach
    void tearDown() {
    }
}

integration testing:
-------------------

import com.fasterxml.jackson.databind.ObjectMapper;

import com.productapp.entities.Product;
import com.productapp.repository.ProductRepo;
import com.productapp.service.ProductService;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.http.MediaType;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.test.web.servlet.ResultActions;

import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.List;

import static org.hamcrest.CoreMatchers.is;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
import static org.springframework.test.web.servlet.result.MockMvcResultHandlers.print;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)

@AutoConfigureMockMvc

public class ProductAppIntegrationTest {
    @Autowired
    private MockMvc mockMvc;

    @Autowired
    private ProductService productService;

    @Autowired
    private ProductRepo productRepo;

    @Autowired
    private ObjectMapper objectMapper;

    @BeforeEach
    void setup(){
        productRepo.deleteAll();
    }

    @Test
    public void givenProductObject_whenCreateProduct_thenReturnSavedProduct() throws Exception{

        // given - precondition or setup
        Product product = Product.builder()
                .name("watch")
                .price(BigDecimal.valueOf(7000))
                .build();

        // when - action or behaviour that we are going test
        ResultActions response = mockMvc.perform(post("/products")
                .contentType(MediaType.APPLICATION_JSON)
                .content(objectMapper.writeValueAsString(product)));

        // then - verify the result or output using assert statements
        response.andDo(print()).
                andExpect(status().isOk())
                .andExpect(jsonPath("$.name",
                        is(product.getName())))
                .andExpect(jsonPath("$.price",
                        is(product.getPrice().intValue())));


    }

    @Test
    public void givenListOfProducts_whenGetAllProducts_thenReturnProductList() throws Exception{
        // given - precondition or setup
        List<Product> listOfProducts = new ArrayList<>();
        listOfProducts.add(Product.builder().name("foo").price(BigDecimal.valueOf(7000)).build());
        listOfProducts.add(Product.builder().name("bar").price(BigDecimal.valueOf(7000)).build());
        productRepo.saveAll(listOfProducts);
        // when -  action or the behaviour that we are going test
        ResultActions response = mockMvc.perform(get("/products"));

        // then - verify the output
        response.andExpect(status().isOk())
                .andDo(print())
                .andExpect(jsonPath("$.size()",
                        is(listOfProducts.size())));

    }

    // positive scenario - valid employee id
    // JUnit test for GET employee by id REST API
    @Test
    public void givenProductId_whenGetProductById_thenReturnProducteObject() throws Exception{
        // given - precondition or setup
        Product product = Product.builder()
                .name("watch")
                .price(BigDecimal.valueOf(7000.00))
                .build();
        productRepo.save(product);

        // when -  action or the behaviour that we are going test
        ResultActions response = mockMvc.perform(get("/products/{id}", product.getId()));

        // then - verify the output
        response.andExpect(status().isOk())
                .andDo(print())
                .andExpect(jsonPath("$.name", is(product.getName())))
                .andExpect(jsonPath("$.price", is(product.getPrice().doubleValue())));

    }
}





JaCoCo 
--------
https://medium.com/@truongbui95/jacoco-code-coverage-with-spring-boot-835af8debc68

Configuration jacoco:
----------------------
<jacoco.version>0.8.8</jacoco.version>

	<build>
		<pluginManagement>
			<plugins>
				<plugin>
					<groupId>org.jacoco</groupId>
					<artifactId>jacoco-maven-plugin</artifactId>
					<version>${jacoco.version}</version>
				</plugin>
			</plugins>
		</pluginManagement>
		<plugins>
			<plugin>
				<groupId>org.springframework.boot</groupId>
				<artifactId>spring-boot-maven-plugin</artifactId>
			</plugin>
			<plugin>
				<groupId>org.jacoco</groupId>
				<artifactId>jacoco-maven-plugin</artifactId>
				<configuration>
					<excludes>
						<!-- com.productapp.Productapp01Application
						com.productapp.exceptions.ProductNotFoundException
						com.productapp.dto.ErrorInfo
						com.productapp.repo.Product
						-->
						<exclude>com/productapp/Productapp01Application.class</exclude>
						<exclude>com/productapp/exceptions/ProductNotFoundException.class</exclude>
						<exclude>com/productapp/dto/ErrorInfo.class</exclude>
						<exclude>com/productapp/repo/Product.class</exclude>
					</excludes>
				</configuration>
				<executions>
					<execution>
						<goals>
							<goal>prepare-agent</goal>
						</goals>
					</execution>
					<execution>
						<id>report</id>
						<phase>test</phase>
						<goals>
							<goal>report</goal>
						</goals>
					</execution>
					<execution>
						<id>jacoco-check</id>
						<goals>
							<goal>check</goal>
						</goals>
						<configuration>
							<rules>
								<rule>
									<element>PACKAGE</element>
									<limits>
										<limit>
											<counter>LINE</counter>
											<value>COVEREDRATIO</value>
											<minimum>00%</minimum>
										</limit>
									</limits>
								</rule>
							</rules>
						</configuration>
					</execution>
				</executions>
			</plugin>
		</plugins>
	</build>
	
	
	
	
SonarCube
------------
https://blog.stackademic.com/integratation-of-sonarqube-with-springboot-6d2cebd4ef95

port : 9000


mvn clean verify sonar:sonar -Dsonar.projectKey=project123 -Dsonar.host.url=http://localhost:9000 -Dsonar.login=sqp_b8a0157a3c6db2cf8663672b4d6423b30f562706
  
mvn clean verify sonar:sonar -Dsonar.projectKey=project123 -Dsonar.host.url=http://localhost:9000 -Dsonar.login=sqp_47977d2c78c6db5d18007022abe47943918dbfb5
  
mvn clean verify sonar:sonar -Dsonar.projectKey=project1 -Dsonar.host.url=http://localhost:9000 -Dsonar.login=sqp_c728475131a378fa2c93963c688a9450b3563b6d
























-----------imp property file configurations------------------

server.port=8090
server.servlet.context-path=/bankapp
spring.datasource.driver-class-name= com.mysql.jdbc.Driver
spring.jpa.properties.hibernate.dialect= org.hibernate.dialect.MySQL5InnoDBDialect
spring.jpa.hibernate.ddl-auto= update
spring.datasource.url=jdbc:mysql://localhost:3306/edu123?useSSL=false
spring.datasource.username=root
spring.datasource.password=root
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.format_sql=true


spring.jpa.hibernate.ddl-auto=update

# if u want to disable logging
#logging.level.root=OFF
#logging.level.org.springframework.boot=OFF
#spring.main.banner-mode=OFF


logging.level.org.springframework.web: DEBUG
logging.level.org.hibernate: ERROR
logging.level.com.productapp: INFO
logging.level.com.productapp.service: INFO

logging.pattern.console= "%d{yyyy-MM-dd } [%thread] %-5level %logger{36} - %msg%n"
#logging pattern for file
logging.pattern.file= "%d{yyyy-MM-dd } [%thread] %-5level %logger{36} - %msg%n"
#i wnat to send logs to a specific file?

spring.jpa.show-sql=true 
spring.banner.location=	

spring.jmx.enabled=true
management.endpoints.web.exposure.include=*
management.endpoints.jmx.exposure.include=*

management.info.env.enabled=true
info.app.encoding=UTF-8
info.app.java.source=21
info.app.java.target=21
info.app.name=productapp
info.app.dev=amit ku

management.endpoint.health.show-details=always
management.endpoint.health.probes.enabled=true
# livenessstate readinessstate
#management.health.livenessstate.enabled=true
#management.health.readinessstate.enabled=true

UserInterface.INTERNAL_SERVER_ERROR=some internal server error
#UserInterface.PRODUCT_ADD_SUCCESS=product added successfully
#UserInterface.PRODUCT_UPDATE_SUCCESS=product added successfully
#UserInterface.PRODUCT_DELETE_SUCCESS=product added successfully
#
#Service.PRODUCT_NOT_EXISTS=Product not exist
#
#
#product.name.absent=Please provide product name
#product.name.invalid=product Name should contain only alphabets and space
#
#product.price.absent=Please provide product price
#account.price.invalid=Please provide correct price bw 100 to 100000

info.key=default
spring.profiles.active=test




server.port=8090
server.servlet.context-path=/productapp
spring.h2.console.enabled=true

spring.datasource.url=jdbc:h2:mem:testdb
spring.datasource.driverClassName=org.h2.Driver
spring.datasource.username=foo
spring.datasource.password=foo
spring.jpa.database-platform=org.hibernate.dialect.H2Dialect

# Custom H2 Console URL
spring.h2.console.path=/h2

spring.jpa.hibernate.ddl-auto=update



